generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// ENUMS
// ==========================================

enum SubscriptionPlan {
  STARTER
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELLED
}

enum Role {
  ADMIN
  SECRETARY
}

enum Channel {
  WHATSAPP
  EMAIL
  SMS
}

enum ConversationStatus {
  OPEN
  PENDING
  CLOSED
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

enum AppointmentStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  NO_SHOW
}

// ==========================================
// MODELS
// ==========================================

model Company {
  id                 String             @id @default(uuid())
  name               String
  subscriptionPlan   SubscriptionPlan   @default(STARTER)
  subscriptionStatus SubscriptionStatus @default(TRIAL)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relazioni (Il Multi-tenant parte da qui)
  users         User[]
  customers     Customer[]
  conversations Conversation[]
  messages      Message[]
  appointments  Appointment[]

  @@map("companies")
}

model User {
  id           String   @id @default(uuid())
  companyId    String
  role         Role     @default(SECRETARY)
  name         String
  email        String   @unique
  passwordHash String
  isActive     Boolean  @default(true) // Soft delete
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relazioni
  company               Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  assignedConversations Conversation[]
  appointments          Appointment[]  // Appuntamenti assegnati a questo operatore

  @@index([companyId])
  @@map("users")
}

model Customer {
  id            String   @id @default(uuid())
  companyId     String
  firstName     String
  lastName      String
  phoneE164     String
  email         String?
  internalNotes String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Dati Anagrafici
  birthDate     DateTime?
  gender        String?   // 'M', 'F', 'N'
  fiscalCode    String?
  vatNumber     String?

  // Relazioni
  company       Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  conversations Conversation[]
  messages      Message[]
  appointments  Appointment[]

  // Indice vitale: un numero di telefono deve essere unico PER SINGOLA AZIENDA
  @@unique([companyId, phoneE164])
  @@map("customers")
}

model Conversation {
  id            String             @id @default(uuid())
  companyId     String
  customerId    String
  channel       Channel            @default(WHATSAPP)
  status        ConversationStatus @default(OPEN)
  assignedTo    String?
  lastMessageAt DateTime           @default(now())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  // Relazioni
  company  Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  assignee User?     @relation(fields: [assignedTo], references: [id], onDelete: SetNull)
  messages Message[]

  // Indice vitale: ordinare le chat nella UI della inbox istantaneamente
  @@index([companyId, lastMessageAt(sort: Desc)])
  @@map("conversations")
}

model Message {
  id             String           @id @default(uuid())
  conversationId String
  companyId      String
  customerId     String
  externalId     String?          @unique // ID di Meta/WhatsApp per evitare duplicati
  direction      MessageDirection
  content        String           @db.Text
  status         MessageStatus    @default(SENT)
  createdAt      DateTime         @default(now())

  // Relazioni
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  company      Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer     Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Indice vitale: caricare i messaggi dentro una singola chat in ordine cronologico
  @@index([conversationId, createdAt(sort: Asc)])
  @@map("messages")
}

model Appointment {
  id          String            @id @default(uuid())
  companyId   String
  customerId  String
  userId      String?           // L'operatore che esegue il servizio (opzionale)
  startTime   DateTime
  endTime     DateTime
  status      AppointmentStatus @default(SCHEDULED)
  serviceType String
  price       Decimal?          @db.Decimal(10, 2)
  description String?           @db.Text
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relazioni
  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([companyId, startTime])
  @@map("appointments")
}